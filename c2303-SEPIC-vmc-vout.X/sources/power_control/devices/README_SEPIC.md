# Single-Ended Primary-Inductor Converter Device Driver

<span id="startDoc"> </span> <!-- start tag for internal references -->

## Class
PowerSmart™ Firmware Framework Component

## Summary
Voltage and constant current mode controlled single-SEPIC converter device driver.

## Table Of Contents

- [Introduction](#intro)
- [Library Usage Guidelines](#lib_use)
- [API Quick-Start Guide](#api_guide)
- [API Public Data Object](#api_objects)
- [SEPIC Converter State Machine](#state_machine)
- [History](#history)


<span id="intro"> </span>
### Introduction
#### Supported Variants
* Single Phase SEPIC Converter

### Special Features
* Tunable Startup Timing
* Current Ramp-Up State for Constant Current Sources for battery chargers (automatic)
* Slope controlled Reference Tuning during normal operation
* Current Sense Calibration Extension (optional)
* GPIO extensions for Power Good Output and Enable Input (optional)

### Description
This generic synchronous SEPIC converter device driver provides a state machine, peripheral configuration template and controller interface for driving one single- or multiphase synchronous or asynchronous SEPIC converter instance in voltage or average current mode control.

All settings of this code library are made in the SEPIC Converter Controller Object defined by the CSEPIC_POWER_CONTROLLER_s data structure. Each API function takes an pointer to a SEPIC Converter Controller Object of type `struct CSEPIC_POWER_CONTROLLER_s` as parameter. This allows to define multiple SEPIC Converter Controller Objects and using the same library files to drive and control multiple, independent converters in parallel. 

### Tool Support
This device driver uses control loop code based on `NPNZ16b` data objects which is generated by the [PowerSmart™ Digital Control Library Designer (DCLD)](https://areiter128.github.io/DCLD). 


[[back](#startDoc)]

<span id="lib_use"> </span>
### Library Usage Guidance

This code library repository must be included in an independent directory within the target project. Changes to any of the files of this repository in the target project environment can be pushed back to this library repository from where these changes can be distributed to one, more or all target projects this library has been used in. The upgrade of library files in a particular target project needs to be performed individually, allowing to individually manage the device driver version used.

### Adding Subtree Repository

#### Step 1 - Adding Subtree Repository to Target Project
##### a) Using Sourcetree Application

Open *Sourcetree* Application
* Open menu *Repository* → *Repository Settings*
* Click *Add* to open the Add Repository dialog

Inside the Repository dialog
* Enter *Remote Name* `subrepo-sepic`
* Enter clone URL/path https://bitbucket.microchip.com/scm/mcu16asmpsl/subrepo-sepic-converter.git
* Under *Optional extended integration* → *Remote Account* select your user account
* Click *OK* to close the dialog

##### b) Using Git Bash

Open Git Bash at root of target project repository and use the following command for adding the new subtree remote:

* `$ git remote add subrepo-sepic https://bitbucket.microchip.com/scm/mcu16asmpsl/subrepo-sepic-converter.git`

#### Step 2) Cloning Subtree Repository

Further using Git Bash use the `subtree add` command to clone the contents of this code library into the target project

* `$ git subtree add --prefix=<code_library_target> subrepo-sepic main --squash`

with `<code_library_target>` = path to sub-folder within the target project directory structure this code library should be cloned to (e.g. my_project.X/sources/power_control/devices).

#### 3) Pulling latest version from Library Repository
When a new version of this code library is available, you can pull it by using the `subtree pull` command in the Git Bash:

`$ git subtree pull --prefix=<code_library_target> subtree-sepic main --squash`

with `<code_library_target>` = path to sub-folder within the target project directory structure this code library has been cloned to (e.g. my_project.X/sources/fault_handler/drivers).

#### 4) Pushing new version back to Library Repository
When changes have been made to files of this code library, the new version can be pushed back to the library repository by using the `subtree push` command in the Git Bash:

`$ git subtree push --prefix=<code_library_target> subtree-sepic feature/version-update --squash`

with `<code_library_target>` = path to sub-folder within the target project directory structure this code library has been cloned to (e.g. my_project.X/sources/fault_handler/drivers).

<span style="color:red">
    <u><b>Note:</b></u><br>
    Pushing changes directly to the library project 'main' or 'develop' branches may be prohibited. 
    Hence, <i><u><b>changes can only be pushed to feature branches</b></u></i>. A Pull Request is required to review and merge changes to 'develop'. Once changes have been approved and merged int 'develop', they may be merged into branch 'main' and thus released as new version through another pull request. This new version of 'main' can be tagged with a new version number and pulled into target projects.
</span>


<br>&nbsp;

[[back](#startDoc)]

<span id="api_guide"> </span>
### API Quick-Start Guide

#### API Public Functions

The API of this device driver provides the following standard power converter functions:

```c

volatile uint16_t dev_csepicConverter_Initialize(volatile struct CSEPIC_POWER_CONTROLLER_s* csepicInstance);
volatile uint16_t dev_csepicConverter_Execute(volatile struct CSEPIC_POWER_CONTROLLER_s* csepicInstance);
volatile uint16_t dev_csepicConverter_Start(volatile struct CSEPIC_POWER_CONTROLLER_s* csepicInstance);
volatile uint16_t dev_csepicConverter_Stop(volatile struct CSEPIC_POWER_CONTROLLER_s* csepicInstance);
volatile uint16_t dev_csepicConverter_Suspend(volatile struct CSEPIC_POWER_CONTROLLER_s* csepicInstance);
volatile uint16_t dev_csepicConverter_Resume(volatile struct CSEPIC_POWER_CONTROLLER_s* csepicInstance);

void __attribute__((near))csepicPwmDistribution(volatile struct CSEPIC_PWM_DISTRIBUTION_s dirstribution_node);
```

Each of these functions takes a function call parameter of type *struct CSEPIC_POWER_CONTROLLER_s* (see below) to be applied to a particular SEPIC converter object and returns an integer return value indicating success (= 1) or failure (= 0) of the function execution.

* **`uint16_t dev_csepicConverter_Initialize(volatile struct CSEPIC_POWER_CONTROLLER_s* csepicInstance)`**<br>&nbsp;
Initializes the sepic converter object by first loading the built-in peripheral configuration templates into the required peripheral special function registers, adding the user settings specified in the *struct CSEPIC_POWER_CONTROLLER_s* SEPIC Converter data object. After a successful peripheral initialization the specified control loop objects will be reset and their histories cleared. <br>&nbsp;<br>All peripherals and control loops will be initialized but kept disabled. The state machine will later enable the peripherals and controller objects used in their proper enable sequence during the startup procedure and no user code intervention is required.<br>&nbsp;<br>

* **`uint16_t dev_csepicConverter_Start(volatile struct CSEPIC_POWER_CONTROLLER_s* csepicInstance)`**<br>&nbsp;
The *csepicConverter_Start* function is initiating the state machine from scratch, by enabling the fundamental peripherals PWM and ADC to start the acquisition of feedback data allowing the state machine to analyze the most recent operating conditions. <br>&nbsp;
Function *csepicConverter_Execute* **should be** called after the execution of this function at a constant frequency.<br>&nbsp;

* **`uint16_t dev_csepicConverter_Stop(volatile struct CSEPIC_POWER_CONTROLLER_s* csepicInstance)`**<br>&nbsp;
The *csepicConverter_Stop* function is terminating the state machine and disabling the fundamental peripherals PWM and ADC to stop the acquisition of feedback data stopping the analysis of the most recent operating conditions. <br>&nbsp;
Function *csepicConverter_Execute* should **not** be called after the execution of this function.<br>&nbsp;

* **`uint16_t dev_csepicConverter_Suspend(volatile struct CSEPIC_POWER_CONTROLLER_s* csepicInstance)`**<br>&nbsp;
The *csepicConverter_Suspend* function is terminating the state machine but keeps the fundamental peripherals PWM and ADC running to continue the acquisition of feedback data allowing the analysis of the most recent operating conditions. <br>&nbsp;
Function *csepicConverter_Execute* **should continued to be** called after the execution of this function at a constant frequency.<br>&nbsp;

* **`uint16_t dev_csepicConverter_Resume(volatile struct CSEPIC_POWER_CONTROLLER_s* csepicInstance)`**<br>&nbsp;
The *csepicConverter_Resume* function is re-initiating the state machine to recover from RESET during which the fundamental peripherals PWM and ADC are running to continue the acquisition of feedback data allowing the analysis of the most recent operating conditions. <br>&nbsp;
Function *csepicConverter_Execute* **should be** called after the execution of this function at a constant frequency.<br>&nbsp;

* **`uint16_t dev_csepicConverter_Execute(volatile struct CSEPIC_POWER_CONTROLLER_s* csepicInstance)`**<br>&nbsp;
The *csepicConverter_Execute* function is executing the state machine managing the initialization, startup and online regulation in voltage and average current mode control. It provides mechanisms for fault handlers to shut down and recover the power supply control in controlled, deterministic procedures using the *dev_csepicConverter_Suspend* and *dev_csepicConverter_Resume* function calls described above.<br>&nbsp;

* **`void __attribute__((near))csepicPwmDistribution(volatile struct CSEPIC_PWM_DISTRIBUTION_s dirstribution_node)`**<br>&nbsp;
This function call is the C function call prototype for the PWM distribution assembly function. This function can be called directly from C or from other assembly routines. it automatically distributes the most recent controller result stored in data field `ControlOutput` of the `CSEPIC_PWM_DISTRIBUTION_s` sub-structure and distributes it onto buck and boost leg under consideration of each leg's control output limits.<br>&nbsp;
Depending on settings in the `CSEPIC_PWM_DISTRIBUTION_STATUS_s` sub structure of the `CSEPIC_PWM_DISTRIBUTION_s` object, this module can also auto-position ADC triggers and apply an user-defined phase-shift between buck and boost leg.<br>&nbsp;

[[back](#startDoc)]

<span id="api_objects"> </span>
#### API Public Data Objects

The SEPIC Converter Data Object holds all configuration data of the user-defined SEPIC converter, covering

* Functional Declarations
    * Startup Timing Declarations
    * User Set Value Declarations
<br> 
* Peripheral Configuration Declarations
    * Switch Node Declarations (PWM and ACMP Configuration)
    * Feedback Channel Declarations (ADC Configuration)
    * GPIO Declarations (GPIO Configuration)
    * Voltage Loop Controller Declarations 
    * Current Loop Controller Declarations (ACMC only, one controller per phase required)
<br> 
* Status and Control Bit Declarations
    
<br> 
* Read-Only Data and Status Information
    * State Machine State Monitoring
    * Runtime Data 

Before the state machine can be used, at least one SEPIC converter data object has to be defined and initialized in the application layer of the user project.

```c

struct CSEPIC_CONVERTER_s 
{
    volatile struct CSEPIC_CONVERTER_STATUS_s status;     ///< SEPIC operation status bits 
    volatile struct CSEPIC_STATE_ID_s state_id;           ///< SEPIC state machine operating state ID
    volatile struct CSEPIC_CONVERTER_STARTUP_s startup;   ///< SEPIC startup timing settings 
    volatile struct CSEPIC_CONVERTER_SETTINGS_s set_values;///< Control field for global access to references
    volatile struct CSEPIC_CONVERTER_DATA_s data;         ///< SEPIC runtime data
    volatile struct CSEPIC_FEEDBACK_SETTINGS_s feedback;  ///< SEPIC converter feedback settings

    volatile struct CSEPIC_SWITCH_NODE_SETTINGS_s sw_node[CSEPIC_MPHASE_COUNT]; ///< SEPIC converter switch node settings
    volatile struct CSEPIC_GPIO_SETTINGS_s gpio;          ///< SEPIC converter additional GPIO specification
    
    volatile struct CSEPIC_LOOP_SETTINGS_s v_loop;        ///< SEPIC voltage control loop object
    volatile struct CSEPIC_LOOP_SETTINGS_s i_loop[CSEPIC_MPHASE_COUNT]; ///< SEPIC Current control loop objects
    
}; ///< SEPIC control & monitoring data structure
typedef struct CSEPIC_CONVERTER_s CSEPIC_CONVERTER_t; ///< SEPIC control & monitoring data structure data type
```
<br>&nbsp;
##### Sub Structure  `struct C4SWBB_CONVERTER_STATUS_s`

The SEPIC converter status bit contains eight read-only, auto-set/clear status bits and eight control bits:
```c
struct CSEPIC_CONVERTER_STATUS_s
{
    union {
    struct{
        volatile bool ready:1;                  ///< Bit #0: status bit, indicating SEPIC converter is initialized and ready to run
        volatile bool adc_active:1;             ///< Bit #1: indicating that ADC has been started and samples are taken
        volatile bool pwm_active:1;             ///< Bit #2: indicating that PWM has been started and ADC triggers are generated
        volatile bool v_loop_clamped:1;         ///< Bit #3: indicating if voltage loop output is clamped to maximum value limit
        volatile bool cs_calib_complete :1;     ///< Bit #4: indicating that current sensor calibration has completed
        volatile bool fault_active :1;          ///< Bit #5: Flag bit indicating system is in enforced shut down mode (usually due to a fault condition)
        volatile bool suspend :1;               ///< Bit #6: Control bit to put the converter in suspend mode (turned off while ENABLE bit is still on)
        volatile bool busy :1;                  ///< Bit #7:  Flag bit indicating that the state machine is executing a process (e.g. startup-ramp)

        volatile bool cs_calib_enable :1;       ///< Bit #8:  Flag bit indicating that current sensors need to calibrated
        volatile unsigned :1;                   ///< Bit #9:  (reserved)
        volatile unsigned :1;                   ///< Bit #10: (reserved)
        volatile unsigned :1;                   ///< Bit #11: (reserved)
        volatile unsigned :1;                   ///< Bit #12: (reserved)
        volatile bool GO :1;                    ///< Bit #13: When set, the GO-bit fires up the power supply
        volatile bool autorun :1;               ///< Bit #14: Control bit determining if charger is starting automatically or on command (using the GO bit)
        volatile bool enabled :1;               ///< Bit #15: Control bit enabling/disabling the charger port
    } __attribute__((packed)) bits;             ///< data structure for single bit addressing operations

	volatile uint16_t value; // buffer for 16-bit word read/write operations
    };
}; // SEPIC Converter Status & Control word
typedef struct CSEPIC_CONVERTER_STATUS_s CSEPIC_CONVERTER_STATUS_t; // SEPIC Converter Status & Control word data type
```

<br>&nbsp;

##### Sub Structure  `struct CSEPIC_STATE_ID_s`

The SEPIC converter State ID is controlled by the state machine and holds the most recent operating state and subsequent sub-state in two separated 16-bit wide variables. While the state machine is executing sequences of operating- and/or sub-states, the busy flag (bit <7> in the status word) will be set.

```c
struct CSEPIC_STATE_ID_s 
{
    union {
    struct { 
        volatile enum CSEPIC_OPSTATES_e opstate_id;   ///< Most recent operating state of main state machine
        volatile enum CSEPIC_SUBSTATES_e substate_id; ///< Most recent operating state of active sub state machine
    } bits;
    volatile uint32_t value; // full state ID value access to main and sub-state machine state
    };
}; // SEPIC Converter State Machine operating state ID
typedef struct CSEPIC_STATE_ID_s CSEPIC_STATE_ID_t;  // SEPIC Converter State Machine operating state ID data type
```

<br>&nbsp;

##### Sub Structures  `struct CSEPIC_STARTUP_PERIOD_HANDLER_s` and `struct CSEPIC_CONVERTER_STARTUP_s`

The SEPIC converter startup declaration consists of multiple delay and ramp-up period, which are defined in the `CSEPIC_CONVERTER_STARTUP_s` data structure. 

```c
struct CSEPIC_CONVERTER_STARTUP_s {
    
    volatile struct CSEPIC_STARTUP_PERIOD_HANDLER_s power_on_delay; ///< Declaration of Power On Delay period and timeout
    volatile struct CSEPIC_STARTUP_PERIOD_HANDLER_s power_good_delay; ///< Declaration of Power Good period and timeout
    volatile struct CSEPIC_STARTUP_PERIOD_HANDLER_s i_ramp;  ///< Declaration of output current ramp reference increment step size and period
    volatile struct CSEPIC_STARTUP_PERIOD_HANDLER_s v_ramp;  ///< Declaration of output voltage ramp reference increment step size and period
    volatile struct CSEPIC_CONVERTER_OLSTARTUP_s open_loop;  ///< Monitored Open Loop Startup Settings
    
}; // Power converter start-up settings and variables
typedef struct CSEPIC_CONVERTER_STARTUP_s  CSEPIC_CONVERTER_STARTUP_t; // Power converter start-up settings and variables data type
```
Each delay is defined by a delay management data structure of type `CSEPIC_STARTUP_PERIOD_HANDLER_t`, defining a period value and a independent counter variable allowing the state machine to count down the specified period. For the Voltage and Current Ramp-Up Periods the control reference will be incremented by the specified reference increment in each counter step until the nominal reference specified in `CSEPIC_CONVERTER_SETTINGS_s` is met.
```c
struct CSEPIC_STARTUP_PERIOD_HANDLER_s {
    
    volatile uint16_t counter;      ///< Soft-Start Execution Counter (read only)
    volatile uint16_t period;       ///< Soft-Start Period (POD, RAMP PERIOD, PGD, etc.)
    volatile uint16_t reference;    ///< Internal dummy reference used to increment/decrement controller reference (read only)
    volatile uint16_t ref_inc_step; ///< Size/value of one reference increment/decrement or this period
    volatile uint16_t ref_minimum;  ///< Minimum starting value of the reference (Commonly =0 but sometimes required to overcome minimum common mode limits)
    volatile uint16_t ref_start_limit;  ///< Specific reference limit during startup if different from common maximum. This setting is only considered in average current mode control loops where the startup current limit might be different from normal operation.
    
}; // Power converter soft-start auxiliary variables
typedef struct CSEPIC_STARTUP_PERIOD_HANDLER_s CSEPIC_STARTUP_PERIOD_HANDLER_t; // Power converter soft-start auxiliary variables data types
```

<br>&nbsp;

##### Sub Structure  `struct CSEPIC_CONVERTER_SETTINGS_s`

The basic converter settings, such as control mode, number of converter phases, voltage and current reference, are specified in the `CSEPIC_CONVERTER_SETTINGS_s` data structure. The current reference will only be valid if the control mode is set to Average Current Mode Control (ACMC) and will be ignored in VOltage Mode Control (VMC)

```c
struct CSEPIC_CONVERTER_SETTINGS_s {
    
    volatile enum CSEPIC_CONTROL_MODE_e control_mode;  ///< Fundamental control mode 
    volatile uint16_t no_of_phases;             ///< number of converter phases
    volatile uint16_t v_ref;                    ///< User reference setting used to control the power converter controller
    volatile uint16_t v_ref_previous;
    volatile uint16_t v_slew_rate;              ///< slew rate of output voltage applied during output voltage reference transitions
    volatile uint16_t i_ref;                    ///< User reference setting used to control the power converter controller
    volatile uint16_t i_slew_rate;              ///< slew rate of output current applied during output current reference transitions
    volatile bool led_driver_mode_enabled;      ///< flag used to enable voltage loop bypass in ISR if running in constant current mode for LED string driving.
    volatile uint16_t led_driver_mode_switch_debounce; ///< Debounce (in # of ISR cycles) before voltage loop is bypassed in CC mode
    volatile uint16_t led_driver_mode_switch_debounce_counter; ///< Debounce (in # of ISR cycles) before voltage loop is bypassed in CC mode  
};  ///> SEPIC converter main settings
typedef struct CSEPIC_CONVERTER_SETTINGS_s CSEPIC_CONVERTER_SETTINGS_t;  ///> SEPIC converter main settings
```

<br>&nbsp;

##### Sub Structure  `struct CSEPIC_CONVERTER_DATA_s`

The basic converter data buffer `CSEPIC_CONVERTER_DATA_s` data structure is used to publish most recent runtime data across the firmware. During operation, control loops and state machine will continuously update this public data buffer. When the SEPIC converter is turned off using the *dev_csepicConverter_Stop()* function, the data buffer will be cleared and won't get updated anymore.

```c
struct CSEPIC_CONVERTER_DATA_s {
    
    volatile uint16_t i_sns[CSEPIC_MPHASE_COUNT];   ///< SEPIC output current
    volatile uint16_t i_out;                        ///< SEPIC common output current
    volatile uint16_t v_in;                         ///< SEPIC input voltage
    volatile uint16_t v_out;                        ///< SEPIC output voltage
    volatile uint16_t temp;                         ///< SEPIC board temperature
    
    volatile uint16_t control_input;                ///< SEPIC most recent control input value (raw input)
    volatile uint16_t control_error;                ///< SEPIC most recent control error value
    volatile uint16_t control_output;               ///< SEPIC most recent control output value
    
}; // SEPIC runtime data buffer
typedef struct CSEPIC_CONVERTER_DATA_s CSEPIC_CONVERTER_DATA_t; // SEPIC runtime data buffer data type
```

<br>&nbsp;

##### Sub Structure  `struct CSEPIC_LOOP_SETTINGS_s`

SEPIC converter control loop settings specify default values for control reference, feedback offset, ADC trigger offset and anti-windup minimum and maximum values, which are used during initialization. Further a pointer to a control loop object of type `NPNZ16b_t` is declared, which holds all the detailed information of the specific control loop, such as filter coefficients, feedback input and control output scaling, pointers to data provider targets and further parameters for advanced control options. 

```c
struct CSEPIC_LOOP_SETTINGS_s {
    
    // Properties (user settings)
    volatile uint16_t reference;            ///< Control loop reference variable
    volatile uint16_t feedback_offset;      ///< Feedback offset value for calibration or bi-direction feedback signals
    volatile uint16_t trigger_offset;       ///< ADC trigger offset value for trigger fine-tuning
    volatile uint16_t minimum;              ///< output clamping value (minimum)
    volatile uint16_t maximum;              ///< output clamping value (maximum)
    // Control Loop Object
    volatile struct NPNZ16b_s* controller;  ///< pointer to control loop object data structure
    // Function pointers
    volatile uint16_t (*ctrl_Initialize)(volatile struct NPNZ16b_s*); ///< Function pointer to INIT routine
    void (*ctrl_Reset)(volatile struct NPNZ16b_s*); ///< Function pointer to RESET routine
    void (*ctrl_Update)(volatile struct NPNZ16b_s*); ///< Function pointer to UPDATE routine
    void (*ctrl_Precharge)(volatile struct NPNZ16b_s*, volatile fractional, volatile fractional); ///< Function pointer to PRECHARGE routine
    
}; ///< User defined settings for control loops; 
typedef struct CSEPIC_LOOP_SETTINGS_s CSEPIC_LOOP_SETTINGS_t; ///< User defined settings for control loops data type
```

<br>&nbsp;

##### Sub Structure  `struct CSEPIC_SWITCH_NODE_SETTINGS_s`

The switch node settings of the SEPIC converter data object specify the user parameters of the PWM configuration supporting a synchronous or asynchronous SEPIC converter switching signal generator. Each converter phase requires its independent switch node definition. The synchronization of multiple PWM generators is automatically configured during the peripheral configuration by the initialization driver `dev_sepic_pconfig.c` of the SEPIC converter device driver. This driver will first load the default peripheral configuration from the built-in SEPIC converter peripheral templates overwriting user parameters with the settings found in this data structure.

The switch node definition is split into three sections:
* Switch Node Buck Leg
* Switch Node Boost Leg
* PWM Distribution Module

```c
struct CSEPIC_SWITCH_NODE_SETTINGS_s 
{
    volatile uint16_t period;                   ///< Switching period
    volatile bool     high_resolution_enable;   ///< Selecting if PWM module should use high-resolution mode 
    
//    volatile struct CSEPIC_SWITCH_NODE_INSTANCE_s buck_leg;     // SEPIC converter buck leg configuration
//    volatile struct CSEPIC_SWITCH_NODE_INSTANCE_s boost_leg;    // SEPIC converter boost leg configuration
//    volatile struct CSEPIC_PWM_DISTRIBUTION_s pwm_distribution; // SEPIC converter buck/boost leg control output distribution configuration
  
// VG_   
    volatile struct CSEPIC_SWITCH_NODE_INSTANCE_s sepic_switch;    // Sepic converter leg configuration
    volatile struct CSEPIC_PWM_DISTRIBUTION_s pwm_distribution; // SEPIC converter buck/boost leg control output distribution configuration
    
    
}; ///< Switching signal timing settings
typedef struct CSEPIC_SWITCH_NODE_SETTINGS_s  CSEPIC_SWITCH_NODE_SETTINGS_t; ///< Switching signal timing settings data type
```

```c
struct CSEPIC_SWITCH_NODE_INSTANCE_s 
{
    volatile uint16_t pwm_instance;         ///< number of the PWM channel used
    volatile uint16_t gpio_instance;        ///< GPIO instance of the selected PWM generator
    //volatile uint16_t gpio_high;            ///< GPIO port pin-number of PWMxH of the selected PWM generator
    volatile uint16_t gpio_low;             ///< GPIO port pin-number of PWMxL of the selected PWM generator
    volatile bool     swap_outputs;         ///< Selecting if PWMxH (default) or PWMxL should be the leading PWM output
    volatile bool     sync_drive;           ///< Selecting if switch node is driven in synchronous or asnchronous mode
    volatile uint16_t phase;                ///< Switching signal phase-shift
    volatile uint16_t duty_ratio_init;      ///< Initial duty cycle when the PWM module is being turned on
    volatile uint16_t duty_ratio_min;       ///< Absolute duty cycle minimum during normal operation
    volatile uint16_t duty_ratio_max;       ///< Absolute duty cycle maximum during normal operation
    volatile uint16_t dead_time_rising;     ///< Dead time setting at rising edge of a half-bridge drive
    volatile uint16_t dead_time_falling;    ///< Dead time setting at falling edge of a half-bridge drive
    volatile uint16_t leb_period;           ///< Leading-Edge Blanking period
    volatile uint16_t trigger_scaler;       ///< PWM triggers for ADC will be generated every n-th cycle
    volatile uint16_t trigger_offset;       ///< PWM triggers for ADC will be offset by n cycles
    
}; ///< Switching signal timing settings
typedef struct CSEPIC_SWITCH_NODE_INSTANCE_s  CSEPIC_SWITCH_NODE_INSTANCE_t; ///< Switching signal timing settings data type
```

```c
struct CSEPIC_PWM_DISTRIBUTION_STATUS_s
{
    union {
    struct{
        volatile bool buck_async_mode :1;       ///< Bit #0:  Control bit suspending the synchronous rectifier switch PWM channel of the buck leg
        volatile bool boost_async_mode :1;      ///< Bit #1:  Control bit suspending the synchronous rectifier switch PWM channel of the boost leg
        volatile unsigned :1;                   ///< Bit #2:  (reserved)
        volatile unsigned :1;                   ///< Bit #3:  (reserved)
        volatile unsigned :1;                   ///< Bit #4:  (reserved)
        volatile unsigned :1;                   ///< Bit #5:  (reserved)
        volatile unsigned :1;                   ///< Bit #6:  (reserved)
        volatile unsigned :1;                   ///< Bit #7:  (reserved)

        volatile unsigned :1;                   ///< Bit #8:  (reserved)
        volatile unsigned :1;                   ///< Bit #9:  (reserved)
        volatile unsigned :1;                   ///< Bit #10: (reserved)
        volatile unsigned :1;                   ///< Bit #11: (reserved)
        volatile unsigned :1;                   ///< Bit #12: (reserved)
        volatile unsigned :1;                   ///< Bit #13: (reserved)
        volatile bool AdcTriggerBEnable :1;     ///< Bit #14: Control bit enabling/disabling ADC Trigger B Auto-Placement 
        volatile bool AdcTriggerAEnable :1;     ///< Bit #15: Control bit enabling/disabling ADC Trigger A Auto-Placement 
    } __attribute__((packed)) bits;             ///< data structure for single bit addressing operations

	volatile uint16_t value; // buffer for 16-bit word read/write operations
    };
}; // SEPIC Converter PWM Distribution Status & Control word
typedef struct CSEPIC_PWM_DISTRIBUTION_STATUS_s CSEPIC_PWM_DISTRIBUTION_STATUS_t; // SEPIC Converter PWM Distribution Status & Control word data type
```


```c
struct CSEPIC_PWM_DISTRIBUTION_s 
{
    // Status & Control Word
    volatile struct CSEPIC_PWM_DISTRIBUTION_STATUS_s Status; ///< PWM Distribution Status and Control word
    
    // Control Output Distribution Settings
    volatile uint16_t  ControlOutput;       ///< Controller output target
    
	volatile uint16_t* ptrBuckLeg;          ///< Pointer to target register of buck leg
	volatile uint16_t* ptrBoostLeg;         ///< Pointer to target register of boost leg
	volatile uint16_t  MinLimitBuck;        ///< minimum value of target A
	volatile uint16_t  MaxLimitBuck;        ///< maximum value of target A
	volatile uint16_t  MinLimitBoost;       ///< minimum value of target B
	volatile uint16_t  MaxLimitBoost;       ///< maximum value of target B
    
    // Buck/Boost Leg Phase Shift
    volatile uint16_t* ptrBoostLegPhaseShiftReg; ///< Pointer to buck vs. boost leg phase shift register
    volatile uint16_t  BoostLegPhaseShift;  ///< Value of phase shift between buck and boost leg in [PWM ticks]
    
    // Voltage/Average Current Mode Control Trigger handling
    volatile uint16_t* ptrAdcTriggerA;      ///< Pointer to ADC trigger A register (e.g. PG1TRIGA)
    volatile uint16_t  OffsetAdcTriggerA;   ///< ADC trigger offset of trigger A to compensate propagation delays 
    volatile uint16_t* ptrAdcTriggerB;      ///< Pointer to ADC trigger B register (e.g. PG1TRIGB)
    volatile uint16_t  OffsetAdcTriggerB;   ///< ADC trigger offset of trigger B to compensate propagation delays 

} __attribute__((packed)); 
typedef struct CSEPIC_PWM_DISTRIBUTION_s CSEPIC_PWM_DISTRIBUTION_t;
```

<br>&nbsp;

##### Sub Structure  `struct CSEPIC_ADC_INPUT_SETTINGS_s` and `CSEPIC_FEEDBACK_SETTINGS_s`

ADC input configuration of feedback channels is set by the `CSEPIC_ADC_INPUT_SETTINGS_s` data structure. Each converter offers the following standard feedback input channels in its `CSEPIC_FEEDBACK_SETTINGS_s` data structure:

* Output Voltage
* Input Voltage
* Inductor Current (one for each converter phase)
* Temperature

```c
struct CSEPIC_FEEDBACK_SETTINGS_s {
    
    volatile struct CSEPIC_ADC_INPUT_SETTINGS_s ad_vin;                       ///< ADC input sampling input voltage
    volatile struct CSEPIC_ADC_INPUT_SETTINGS_s ad_vout;                      ///< ADC input sampling output voltage
    volatile struct CSEPIC_ADC_INPUT_SETTINGS_s ad_isns[CSEPIC_MPHASE_COUNT];   ///< ADC input sampling phase current
    volatile struct CSEPIC_ADC_INPUT_SETTINGS_s ad_temp;                      ///< ADC input sampling temperature
    
}; ///< SEPIC converter feedback declarations
typedef struct CSEPIC_FEEDBACK_SETTINGS_s CSEPIC_FEEDBACK_SETTINGS_t; ///< SEPIC converter feedback declarations data type
```

Each feedback channel can be enabled or disabled. Disabled channels will be ignored during initialization and will remain inactive during operation. The peripheral configuration is performed by the initialization driver `dev_sepic_pconfig.c` of the SEPIC converter device driver. This driver will first load the default peripheral configuration from the built-in SEPIC converter peripheral templates overwriting user parameters with the settings found in this data structure.

```c
struct CSEPIC_ADC_INPUT_SETTINGS_s {
    
    volatile bool enabled;                  ///< input channel enable bit
    volatile uint16_t* adc_buffer;          ///< pointer to ADC result buffer
    volatile uint16_t gpio_instance;        ///< GPIO instance of the selected PWM generator
    volatile uint8_t adc_input;             ///< number of the ADC input channel used
    volatile uint8_t adc_core;              ///< number of the ADC core connected to the selected channel
    volatile uint8_t trigger_source;        ///< input channel trigger source
    volatile bool interrupt_enable;         ///< input channel interrupt enable bit
    volatile bool early_interrupt_enable;   ///< input channel early interrupt enable bit
    volatile bool differential_input;       ///< input channel differential mode enable bit
    volatile bool signed_result;            ///< input channel singed result mode enable bit
    volatile bool level_trigger;            ///< input channel level trigger mode enable bit
    volatile struct CSEPIC_ADC_INPUT_SCALING_s scaling; ///< normalization scaling settings

}; ///< ADC input channel configuration
typedef struct CSEPIC_ADC_INPUT_SETTINGS_s CSEPIC_ADC_INPUT_SETTINGS_t; ///< ADC input channel configuration data type
```

Supporting calculations of power, voltage ratios, gains or Root Mean Square (RMS) values feedback channels may have to be scaled/normalized. For this purpose the `CSEPIC_ADC_INPUT_SCALING_s` data structure was added allowing users to specify the feedback value scaling information in form of a fast floating point slope and integer offset value.

```c
struct CSEPIC_ADC_INPUT_SCALING_s {
    
    volatile int16_t factor; ///< Fractional scaling factor (range -1 ... 0.99969)
    volatile int16_t scaler; ///< Feedback bit-shift scaler used for number normalization
    volatile int16_t offset; ///< Signal offset as signed integer to be subtracted from ADC input

}; ///< ADC input signal scaling = (ADCBUF - <offset>) * <factor> >> 2^<scaler>
typedef struct CSEPIC_ADC_INPUT_SCALING_s CSEPIC_ADC_INPUT_SCALING_t; ///< ADC input signal scaling data type
```

<br>&nbsp;

##### Sub Structure  `struct CSEPIC_GPIO_INSTANCE_s` and `CSEPIC_GPIO_SETTINGS_s`

The SEPIC converter device driver supports one Enable input (EN) and one Power Good output (PG) as two basic general purpose input/outputs (GPIO) for low-level hardware sequencing of converter stages.

```c
struct CSEPIC_GPIO_SETTINGS_s {
    
    volatile struct CSEPIC_GPIO_INSTANCE_s EnableInput; ///< External ENABLE input
    volatile struct CSEPIC_GPIO_INSTANCE_s PowerGood; ///< Power Good Output

}; ///< GPIO instance of the converter control GPIO
typedef struct CSEPIC_GPIO_SETTINGS_s CSEPIC_GPIO_SETTINGS_t; ///< GPIO instance of the converter control GPIO data type
```

Each GPIO can be configured by the settings specified in the `CSEPIC_GPIO_INSTANCE_s` data structure. The Input/Output type can be set to 

* Input (=1, max. input voltage = 3.3 V)
* Push-Pull Output (=0, max. sink-/source-current = 4 mA, max. output voltage = 3.3 V)
* Open-Drain Output (=0, max. sink-current = 4 mA, max. output voltage = 3.3/5.0 V)

```c
struct CSEPIC_GPIO_INSTANCE_s {
    
    volatile bool enabled;      ///< Specifies, if this IO is used or not
    volatile uint16_t port;     ///< GPIO port instance number (0=Port RA, 0=Port RB, 0=Port RC, etc.)
    volatile uint16_t pin;      ///< GPIO port pin number
    volatile uint16_t polarity; ///< Output polarity, where 0=ACTIVE HIGH, 1=ACTIVE_LOW
    volatile uint16_t io_type;  ///< Input/Output definition (0=push-pull output, 1=input, 2=open-drain output)

}; ///< GPIO instance of the converter control GPIO
typedef struct CSEPIC_GPIO_INSTANCE_s CSEPIC_GPIO_INSTANCE_t; ///< GPIO instance of the converter control GPIO data type
```


[[back](#startDoc)]

<span id="state_machine"> </span>
### SEPIC Converter State Machine

The SEPIC Converter State Machine is broken down into two major segments, Default Operating States (opstate) and Sub-States (substate)

* **Default Operating States**<br>&nbsp;

    * *State_Initialize*
    Initializes the pre-configured chip peripherals enabling the PWM and ADC to start the continuous acquisition of data allowing the analysis of the system status.<br>&nbsp;
    * *State_Reset*
    Disables the PWM outputs while keeping the PWM itself running as trigger generator of the ADC module, and clears dynamic control parameters such as error and control histories to ensure a deterministic state at startup.<br>&nbsp;
    * *State_Standby*
    Waits for all status bits to be set, fault and suspend bits to be cleared and the GO bit to be set.<br>&nbsp;
    * *State_RampUp*
    The Ramp-Up state splits up into converter-specific startup sub-states, managing the specific startup procedure of a synchronous or asynchronous single- or multiphase SEPIC converter topology. This topology-specific startup procedure also includes the startup timing specified by the `CSEPIC_CONVERTER_STARTUP_s` data structure parameters.<br>&nbsp;
    * *State_Online*
    Once the start procedure has been completed successfully, the converter state machine drops into constant regulation mode, where it will remain until the converter is shut-down or suspended. During constant regulation the control reference is monitored. If the value of the control reference is changed, the state machine will tune into the new reference by generating a defined defined transition ramp using the ramp slope specified in the startup voltage ramp timing.<br>&nbsp;
    * *State_Error*
    Should any of the states ever return an error, the converter will be shut down and the state machine will fall back into an error state, from which is will recover automatically with the fault_active flag (bit <5> of the status word) being set.<br>&nbsp;


* **Topology-Specific Startup Sub-States**<br>&nbsp;

The SEPIC converter startup sub-state machine manages the power topology-specific startup procedure of a SEPIC converter, tailored to its configuration, control and operating mode. It also incorporates the user definition of the startup timing specified in the `CSEPIC_CONVERTER_STARTUP_s` data structure.


* *SubState_PowerOnDelay*
Waiting period while the converter is kept in a disabled state until the Power-On Delay (POD) specified in the `CSEPIC_CONVERTER_STARTUP_s` data structure has expired.<br>&nbsp;
* *SubState_PrepareVRampUp*
In this state the most recent voltage ratio between the inductor terminals is measured and the expected duty ratio at the startup frequency is calculated to ensure a smooth startup without accidental reverse current or forward current spikes at startup against a pre-biased output. The estimated startup duty ratio value is then programmed into PWM registers and the control loop histories get pre-charged and the startup control reference is set to match the output voltage.<br>&nbsp;
* *SubState_VRampUp*
In this state the PWM outputs and control loops are enabled and the converter starts to operate. Due to the ramp-up pre-charge of the previous state, the expected output power is close to zero. With every execution cycle of the state machine the control reference is linearly incremented by the given amount of ticks until the ramp-up reference value matches desired value specified by the user by `v_ref` in the `CSEPIC_CONVERTER_SETTINGS_s` data structure.<br>&nbsp;
* *SubState_IRampUp*
This state is only executed in Average Current Mode Control (ACMC) and only if the voltage loop hist an output saturation limit during the execution of the previous voltage ramp-up state. This additional output current ramp-up procedure has been introduced as controlled constant-current ramp-up control when ramping up the output against large capacitive loads or when this SEPIC converter device driver is used in a constant current source application.<br>&nbsp;
* *SubState_PowerGoodDelay*
Waiting period while the converter is kept in a enabled state at constant output regulation until the Power Good Delay (PGD) specified in the `CSEPIC_CONVERTER_STARTUP_s` data structure has expired.<br>&nbsp;

[[back](#startDoc)]

---
<span id="history"> </span>
##### History:
* 07/24/2019 v1.0 (M91406) Initial release
* 11/02/2020 v2.0 (M91406) Modular state machine with startup sub-states
* 12/21/2020 v2.1 (M91406) Added current sense calibration function extensions to state machine
* 02/22/2021 v2.2 (M91406) Modified voltage reference management during startup, ensuring user setting is always loaded correctly before voltage ramp-up
* 03/31/2021 v2-3 (M91406) Added non-zero current sense common mode voltage startup procedure to state machine


---
© 2021, Microchip Technology Inc.
